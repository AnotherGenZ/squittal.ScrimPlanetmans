@using squittal.ScrimPlanetmans.ScrimMatch;
@using squittal.ScrimPlanetmans.ScrimMatch.Messages;
@using squittal.ScrimPlanetmans.ScrimMatch.Models;
@using squittal.ScrimPlanetmans.Services.ScrimMatch;

@inject IScrimTeamsManager ScrimTeamsManager
@inject IScrimMessageBroadcastService MessageService
@* InfantryMatchReportPlayerStatsRow *@

@if (_player != null)
{
    <div id="@($"{_player.NameDisplay}-stats")" class="stats-row player">
        <div id="@($"{_player.NameDisplay}-label")" class="label">@_player.NameDisplay (@(_currentMaxPoints)) </div>
        <div id="@($"{_player.NameDisplay}-score")" class="score stats-value">@_player.EventAggregate.Points</div>
        <div id="@($"{_player.NameDisplay}-graph")" class="graph">
            <div id="@($"{_player.NameDisplay}-graph-bar")" class="graph-bar" style="width: @($"{_pointGraphWidth}%")"></div>
        </div>
        <div id="@($"{_player.NameDisplay}-net")" class="net stats-value">@_player.EventAggregate.NetScore</div>
        <div id="@($"{_player.NameDisplay}-kills")" class="kills stats-value">@_player.EventAggregate.Kills</div>
        <div id="@($"{_player.NameDisplay}-deaths")" class="deaths stats-value">@_player.EventAggregate.Deaths</div>
        <div id="@($"{_player.NameDisplay}-hsr")" class="hsr stats-value">@_player.EventAggregate.HeadshotRatio</div>
        <div id="@($"{_player.NameDisplay}-assists")" class="assists stats-value">@_player.EventAggregate.DamageAssists</div>
        <div id="@($"{_player.NameDisplay}-utils")" class="utils stats-value">@_player.EventAggregate.UtilityAssists</div>
    </div>
}

@code {
    [Parameter]
    public Player i_Player { get; set; }

    [Parameter]
    public string i_CharacterId { get; set; }

    private Player _player { get; set; }

    private string _renderedCharacterId { get; set; }

    private ScrimEventAggregate _renderedEventAggregate { get; set; }

    private decimal _pointGraphWidth { get; set; } = 4;
    private int _currentMaxPoints { get; set; } = 0;


    #region Initialization Methods
    protected override void OnInitialized()
    {
        //MessageService.RaiseTeamPlayerChangeEvent += ReceiveTeamPlayerChangeEvent;
        MessageService.RaisePlayerStatUpdateEvent += ReceivePlayerStatUpdateEvent;
        //MessageService.RaiseTeamStatUpdateEvent += ReceiveTeamStatUpdateEvent;
        //MessageService.RaisePlayerLoginEvent += ReceivePlayerLoginEvent;
        //MessageService.RaisePlayerLogoutEvent += ReceivePlayerLogoutEvent;

        if (_player == null)
        {
            //_player = ScrimTeamsManager.GetPlayerFromId(i_CharacterId);
            _player = i_Player;
            //_renderedEventAggregate = _player.EventAggregate;
            _renderedEventAggregate = new ScrimEventAggregate();
            _renderedEventAggregate.Add(_player.EventAggregate);
        }
        else
        {
            //_renderedEventAggregate = _player.EventAggregate;
            _renderedEventAggregate = new ScrimEventAggregate();
            _renderedEventAggregate.Add(_player.EventAggregate);
        }

        _currentMaxPoints = ScrimTeamsManager.MaxPlayerPointsTracker.GetMaxPoints();

        UpdatePointGraphWidth();
    }

    protected override void OnParametersSet()
    {
        //if (i_CharacterId != _renderedCharacterId)
        if (_player != i_Player)
        {
            _renderedCharacterId = i_CharacterId;
            //_player = ScrimTeamsManager.GetPlayerFromId(_renderedCharacterId);
            _player = i_Player;

            //_renderedEventAggregate = _player.EventAggregate;
            _renderedEventAggregate = new ScrimEventAggregate();
            _renderedEventAggregate.Add(_player.EventAggregate);

            InvokeAsync(() =>
            {
                _currentMaxPoints = ScrimTeamsManager.MaxPlayerPointsTracker.GetMaxPoints();

                UpdatePointGraphWidth();

                StateHasChanged();
            });

            //InvokeAsync(() =>
            //{
            //    StateHasChanged();
            //});

            //InvokeAsyncStateHasChanged();
        }
    }
    #endregion Initialization Methods

    #region Event Handling
    private void ReceivePlayerStatUpdateEvent(object sender, PlayerStatUpdateEventArgs e)
    {
        var player = e.Message.Player;
        var overlayData = e.Message.OverlayMessageData;

        if (overlayData.RedrawPointGraph)
        {
            if (player == _player)
            {
                //_renderedEventAggregate = player.EventAggregate;
                _renderedEventAggregate = new ScrimEventAggregate();
                _renderedEventAggregate.Add(_player.EventAggregate);
            }

            _currentMaxPoints = overlayData.MatchMaxPlayerPoints;

            UpdatePointGraphWidth();

            InvokeAsync(() =>
            {

                StateHasChanged();
            });

            //InvokeAsync(() =>
            //{
            //    StateHasChanged();
            //});

            //InvokeAsyncStateHasChanged();

            return;
        }

        //if (player != _player)
        //{
        //    if (overlayData.RedrawPointGraph)
        //    {
        //        UpdatePointGraphWidth();

        //        InvokeAsync(() =>
        //        {
        //            StateHasChanged();
        //        });
        //    }

        //    return;
        //}

        if (player == _player)
        {
            if (RenderedStatsHaveChanged(player.EventAggregate, out var redrawGraph))
            {
                //_renderedEventAggregate = player.EventAggregate;
                _renderedEventAggregate = new ScrimEventAggregate();
                _renderedEventAggregate.Add(_player.EventAggregate);

                _currentMaxPoints = overlayData.MatchMaxPlayerPoints;

                if (redrawGraph)
                {
                    UpdatePointGraphWidth();
                }

                InvokeAsync(() =>
                {

                    StateHasChanged();
                });
                //InvokeAsyncStateHasChanged();
            }
        }
    }

    private void ReceiveTeamStatUpdateEvent(object sender, TeamStatUpdateEventArgs e)
    {
        var overlayData = e.Message.OverlayMessageData;

        if (overlayData.RedrawPointGraph)
        {
            _currentMaxPoints = overlayData.MatchMaxPlayerPoints;

            UpdatePointGraphWidth();

            InvokeAsync(() =>
            {

                StateHasChanged();
            });

            //UpdatePointGraphWidth();

            //InvokeAsync(() =>
            //{
            //    StateHasChanged();
            //});

            //InvokeAsyncStateHasChanged();
        }
    }
    #endregion Event Handling

    private bool RenderedStatsHaveChanged(ScrimEventAggregate newAggregate, out bool redrawGraph)
    {
        redrawGraph = false;

        if (_renderedEventAggregate.Points != newAggregate.Points)
        {
            redrawGraph = true;
            return true;
        }
        else if (_renderedEventAggregate.NetScore != newAggregate.NetScore)
        {
            return true;
        }
        else if (_renderedEventAggregate.Kills != newAggregate.Kills)
        {
            return true;
        }
        else if (_renderedEventAggregate.HeadshotRatio != newAggregate.HeadshotRatio)
        {
            return true;
        }
        else if (_renderedEventAggregate.DamageAssists != newAggregate.DamageAssists)
        {
            return true;
        }
        else if (_renderedEventAggregate.UtilityAssists != newAggregate.UtilityAssists)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    private void UpdatePointGraphWidth()
    {
        //var maxPoints = ScrimTeamsManager.MaxPlayerPointsTracker.GetMaxPoints();

        var maxPoints = _currentMaxPoints;

        //var playerPoints = _player.EventAggregate.Points;
        var playerPoints = _renderedEventAggregate.Points;

        decimal pointGraphWidth = (playerPoints > 1) ? Math.Ceiling(90 * ((decimal)playerPoints / (decimal)maxPoints)) : 4;

        _pointGraphWidth = pointGraphWidth;
    }

    private double GetStatOpacity(int value)
    {
        return (value != 0)
            ? 1.0
            : 0.5;
    }

    private void InvokeAsyncStateHasChanged()
    {
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }
}

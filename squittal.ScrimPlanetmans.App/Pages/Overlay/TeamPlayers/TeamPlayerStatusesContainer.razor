@using squittal.ScrimPlanetmans.CensusStream;
@using squittal.ScrimPlanetmans.Models.Planetside;
@using squittal.ScrimPlanetmans.ScrimMatch;
@using squittal.ScrimPlanetmans.ScrimMatch.Messages;
@using squittal.ScrimPlanetmans.Models;
@using squittal.ScrimPlanetmans.ScrimMatch.Models;
@using squittal.ScrimPlanetmans.Services.Planetside;
@using squittal.ScrimPlanetmans.Services.ScrimMatch;
@using System.Collections.Concurrent;

@inject IScrimTeamsManager ScrimTeamsManager
@inject IWebsocketMonitor WebsocketMonitor
@inject IScrimMatchEngine ScrimMatchEngine
@inject IOutfitService OutfitService
@inject IWorldService WorldService
@inject IFactionService FactionService
@inject IScrimMessageBroadcastService MessageService

@if (_team != null)
{
    <div class="players @($"players{i_TeamOrdinal}") @SqCssHelper.GetFactionClassFromId(_team.FactionId)">
    
        @lock(_renderedPlayers)
        {
            foreach(var player in _renderedPlayers)
            {
                <TeamPlayerStatusRow i_TeamOrdinal=i_TeamOrdinal i_player=player />
            }
        }
    </div>
}

@code {
    [Parameter]
    public int i_TeamOrdinal { get; set; }

    private int _renderedTeamOrdinal { get; set; }

    #region Team & Players
    private Team _team;

    private List<Outfit> _teamOutfits = new List<Outfit>();

    private List<Player> _teamPlayers = new List<Player>();

    private List<Player> _teamPlayersOnline = new List<Player>();

    private List<Player> _teamPlayersParticipating = new List<Player>();

    private List<Player> _teamPlayersVisible = new List<Player>();

    private List<Player> _teamNonOutfitPlayers = new List<Player>();

    private List<Player> _renderedPlayers { get; set; } = new List<Player>();
    private int _renderedPlayersCount { get; set; } = 0;
    private ConcurrentQueue<TeamPlayerChangeMessage> _teamPlayersQueue { get; set; } = new ConcurrentQueue<TeamPlayerChangeMessage>();


    #endregion

    #region Helpers
    #endregion

    #region Initialization Methods
    protected override void OnInitialized()
    {
        MessageService.RaiseTeamPlayerChangeEvent += ReceiveTeamPlayerChangeEvent;
        MessageService.RaisePlayerStatUpdateEvent += ReceivePlayerStatUpdateEvent;
        MessageService.RaiseTeamFactionChangeEvent += ReceiveTeamFactionChangeEvent;
    }

    protected override void OnParametersSet()
    {
        if (i_TeamOrdinal != _renderedTeamOrdinal && i_TeamOrdinal >= 0)
        {
            _renderedTeamOrdinal = i_TeamOrdinal;
            InitializeTeamData();
        }
    }

    private void InitializeTeamData()
    {
        _team = ScrimTeamsManager.GetTeam(i_TeamOrdinal);

        InvokeAsync(() =>
        {
            lock (_renderedPlayers)
            {
                var visiblePlayers = _team.Players.Where(p => ShouldShowPlayer(p) && !_renderedPlayers.Contains(p));

                _renderedPlayers.AddRange(visiblePlayers);

                _renderedPlayersCount = _renderedPlayers.Count();

                StateHasChanged();
            }
        });
    }
    #endregion

    #region Event Handling
    private void ReceiveTeamPlayerChangeEvent(object sender, TeamPlayerChangeEventArgs e)
    {
        var message = e.Message;

        var player = message.Player;
        if (player.TeamOrdinal != i_TeamOrdinal)
        {
            return;
        }

        message.ChangeType = ShouldShowPlayer(player) ? TeamPlayerChangeType.Add : TeamPlayerChangeType.Remove;

        _teamPlayersQueue.Enqueue(message);

        UpdateRenderedPlayers();

        //switch (message.ChangeType)
        //{
        //    case TeamPlayerChangeType.Add:
        //        HandleTeamPlayerChangeAdd(message);
        //        break;

        //    case TeamPlayerChangeType.Remove:
        //        HandleTeamPlayerChangeRemove(message);
        //        break;
        //}

        //InvokeAsync(() =>
        //{
        //    StateHasChanged();
        //});
    }

    private void HandleTeamPlayerChangeAdd(TeamPlayerChangeMessage message)
    {
        var player = message.Player;

        if (TryAddPlayerToVisiblePlayers(player))
        {
            InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }
    }

    private void HandleTeamPlayerChangeRemove(TeamPlayerChangeMessage message)
    {
        var player = message.Player;

        _teamPlayersVisible.RemoveAll(p => p.Id == player.Id);

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private void ReceivePlayerStatUpdateEvent(object sender, PlayerStatUpdateEventArgs e)
    {
        var message = e.Message;
        var player = message.Player;

        if (player.TeamOrdinal != i_TeamOrdinal)
        {
            return;
        }

        //var changeType = player.IsActive ? TeamPlayerChangeType.Add : TeamPlayerChangeType.Remove;
        var changeType = ShouldShowPlayer(player) ? TeamPlayerChangeType.Add : TeamPlayerChangeType.Remove;

        var changeMessage = new TeamPlayerChangeMessage(player, changeType);

        _teamPlayersQueue.Enqueue(changeMessage);

        UpdateRenderedPlayers();

        //if (ShouldShowPlayer(player))
        //{
        //    TryAddPlayerToVisiblePlayers(player);
        //}
        //else
        //{
        //    _teamPlayersVisible.RemoveAll(p => p.Id == player.Id);
        //}

        //InvokeAsync(() =>
        //{
        //    StateHasChanged();
        //});
    }

    private void ReceivePlayerLoginEvent(object sender, PlayerLoginEventArgs e)
    {
        var player = e.Message.Player;

        if (player.TeamOrdinal != i_TeamOrdinal)
        {
            return;
        }

        if (TryAddPlayerToVisiblePlayers(player))
        {
            InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }
    }

    private void ReceivePlayerLogoutEvent(object sender, PlayerLogoutEventArgs e)
    {
        var player = e.Message.Player;

        if (player.TeamOrdinal != i_TeamOrdinal)
        {
            return;
        }

        // TODO: what players should be visible by default?

        // Only remove the player from the visible list if they haven't done anything in the match
        if (!_teamPlayersParticipating.Any(p => p.Id == player.Id))
        {
            _teamPlayersVisible.RemoveAll(p => p.Id == player.Id);
        }

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private void ReceiveTeamFactionChangeEvent(object sender, TeamFactionChangeEventArgs e)
    {
        var message = e.Message;

        var teamOrdinal = message.TeamOrdinal;

        if (teamOrdinal != i_TeamOrdinal)
        {
            return;
        }

        InvokeAsyncStateHasChanged();
    }
    #endregion Event Handling
    private void UpdateRenderedPlayers()
    {
        InvokeAsync(() =>
        {
            lock (_renderedPlayers)
            {
                while (_teamPlayersQueue.TryDequeue(out TeamPlayerChangeMessage changeMessage))
                {
                    var player = changeMessage.Player;

                    if (changeMessage.ChangeType == TeamPlayerChangeType.Remove)
                    {
                        _renderedPlayers.Remove(player);
                    }
                    else if (changeMessage.ChangeType == TeamPlayerChangeType.Add && !_renderedPlayers.Contains(player))
                    {
                        _renderedPlayers.Add(player);
                    }
                }

                _renderedPlayersCount = _renderedPlayers.Count();

                StateHasChanged();
            }
        });
    }


    private bool TryAddPlayerToVisiblePlayers(Player player)
    {
        if (CanAddPlayerToVisiblePlayers(player))
        {
            _teamPlayersVisible.Add(player);
            return true;
        }
        return false;
    }

    private bool CanAddPlayerToVisiblePlayers(Player player)
    {
        //return (player.IsParticipating || player.IsOnline) && !player.IsBenched && !_teamPlayersVisible.Any(p => p.Id == player.Id);
        return ShouldShowPlayer(player) && !_teamPlayersVisible.Any(p => p.Id == player.Id);
    }

    private bool ShouldShowPlayer(Player player)
    {
        return (player.IsActive || player.IsOnline) && !player.IsBenched;
    }

    private void InvokeAsyncStateHasChanged()
    {
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }
}
